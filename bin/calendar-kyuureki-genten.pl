use strict;
use warnings;
use Path::Tiny;
use JSON::PS;

my $data_path = path (__FILE__)->parent->parent->child ('tables');
my $Data = {};

{
  ## Derived from |Time::Local|
  ## <http://cpansearch.perl.org/src/DROLSKY/Time-Local-1.2300/lib/Time/Local.pm>.

  use constant SECS_PER_MINUTE => 60;
  use constant SECS_PER_HOUR   => 3600;
  use constant SECS_PER_DAY    => 86400;

  my %Cheat;
  my $Epoc = 0;
  $Epoc = _daygm( gmtime(0) );
  %Cheat = ();

  sub _daygm {

    # This is written in such a byzantine way in order to avoid
    # lexical variables and sub calls, for speed
    return $_[3] + (
        $Cheat{ pack( 'ss', @_[ 4, 5 ] ) } ||= do {
            my $month = ( $_[4] + 10 ) % 12;
            my $year  = $_[5] + 1900 - int($month / 10);

            ( ( 365 * $year )
              + int( $year / 4 )
              - int( $year / 100 )
              + int( $year / 400 )
              + int( ( ( $month * 306 ) + 5 ) / 10 )
            )
            - $Epoc;
        }
    );
  }

  sub timegm_nocheck {
    my ( $sec, $min, $hour, $mday, $month, $year ) = @_;

    my $days = _daygm( undef, undef, undef, $mday, $month, $year - 1900);

    return $sec
           + ( SECS_PER_MINUTE * $min )
           + ( SECS_PER_HOUR * $hour )
           + ( SECS_PER_DAY * $days );
  }
}

my $map = q{

445-01-24+1  1010101010101 5
101010101010
121121212121

2121212112121 2
212121212121
1212121212121 10

211212121212
121212112121
2121212121211 6

212121212121
211212121212
1212121121212 3

121212121211
2121212121212 12
121121212121

212121121212
1212121212112 9
121212121212

121121212121
2121211212121 5
212121212112

121212121212
1211212121212 1
121211212121

2121212121121 11
212121212121
211212121212

#472
1212112121212 7
121212121121
212121212121

2112121212121 3
212112121212
1212121211212 12

121212121212
112121212121
2121121212121 9

212121211212
121212121212
1121212121212 5

#484
121121212121
212121211212
1212121212121 1

121212121212
1211212121212 10
121212112121

212121212121
1212121212121 7
211212121212

121212112121
2121212121211 4
212121212121

2112121212121 12
212121121212
121212121211

2121212121212 8
112121212121
212121121212

502-1-24+2 1212121212112 5
121212121212
112121212121

2121211212121 2
212121212112
1212121212121 10

121212121212
121211212121
2121212121121 6

212121212121
121212121212
1212112121212 3

121212121121
2121212121211 12
212121212121

212112121212
1212121211212 9
121212121212

112121212121
2121121212121 5
212121211212

121212121212
1121212121212 2
121121212121

#526
2121212112121 11
212121212121
121212121212

1211212121212 7
121212112121
212121212121

1212121212121 3
211212121212
1212121121212 12

121212121211
212121212121
2112121212121 9

212121121212
121212121211
2121212121212 5

112121212121
212121121212
1212121212112 1

#544
121212121212
1121212121212 10
121211212121

212121212112
1212121212121 7
121212121212

121211212121
2121212121121 4
212121212121

1212121212121 12
212112121212
121212121121

2121212121211 8
212121212121
212112121212

1212121211212 5
121212121211
212121212121

2121121212121 2
212121211212
1212121212112 10

121212121212
121121212121
2121212112121 6

#568
212121212112
121212121212
1211212121212 4

121212112121
2121212121121 12
212121212121

211212121212
1212121121212 8
121212121121

212121212121
2112121212121 5
212121121212

121212121211
2121212121212 2
112121212121

2121211212121 11
212121212112
121212121212

#586
1121212121212 7
121211212121
212121212112

1212121212121 3
121212121212
1212112121212 12

#592
121212121121
212121212121
1212121212121 9

212112121212
121212121121
2121212121211 5

212121212121
212112121212
1212121211212 1

788-2-12+4 212122121211
121212212121
1121212122121 3

211121221212
1122112112122 11
121212112121

};

sub gdate ($$$) {
  my ($y, $m, $d) = @_;
  my @result = gmtime timegm_nocheck 0, 0, 0, $d, $m-1, $y;
  return sprintf '%04d-%02d-%02d',
      $result[5]+1900, $result[4]+1, $result[3];
} # gdate

my $next_ymd;
for (split /\x0D?\x0A/, $map) {
  if (/^(\d+)-(\d+)-(\d+)\+(\d+)\s+([012]{12,13})(?:\s+(\d+))?$/) {
    my ($y, $m, $d) = ($1, $2, $3);
    my $delta = $4;
    my $mt = $5;
    $mt =~ tr/2/0/;
    my $leap_month = $6;

    my @month = map { sprintf '%02d', $_ } 1..12;
    splice @month, $leap_month, 0, (sprintf "%02d'", $leap_month)
        if defined $leap_month;

    my $month_index = 0;
    for (split //, $mt) {
      my $new = gdate $y, $m, $d + $delta;
      my $old = sprintf '%04d-%s-01', $y, $month[$month_index];
      $Data->{mapping}->{$new} = $old;
      $month_index++;
      $delta += 29 + $_;
    }
    my $is_leap_year = (($y % 4) == 0 and
                        not (($y % 100 == 0) and not ($y % 400 == 0)));
    my $ld = $is_leap_year ? 1 : 0;
    $next_ymd = [$y + 1, $m, $d + $delta - 365 - $ld];
  } elsif (/^([012]{12,13})(?:\s+(\d+))?$/) {
    my ($y, $m, $d) = @$next_ymd;
    my $delta = 0;
    my $mt = $1;
    $mt =~ tr/2/0/;
    my $leap_month = $2;

    my @month = map { sprintf '%02d', $_ } 1..12;
    splice @month, $leap_month, 0, (sprintf "%02d'", $leap_month)
        if defined $leap_month;

    my $month_index = 0;
    for (split //, $mt) {
      my $new = gdate $y, $m, $d + $delta;
      my $old = sprintf '%04d-%s-01', $y, $month[$month_index];
      $Data->{mapping}->{$new} = $old;
      $month_index++;
      $delta += 29 + $_;
    }
    my $is_leap_year = (($y % 4) == 0 and
                        not (($y % 100 == 0) and not ($y % 400 == 0)));
    my $ld = $is_leap_year ? 1 : 0;
    $next_ymd = [$y + 1, $m, $d + $delta - 365 - $ld];
  } elsif (/^\s*#/) {
    #
  } elsif (/\S/) {
    die "Bad line: $_";
  }
}

my $data1 = q{
637 9 = 9 25
641 8 = 9 10
648 1 = 1 30
648 2 = 2 29
648 3 = 3 29
648 4 = 4 28
648 5 = 5 28
648 6 = 6 26
648 7 = 7 26
648 8 = 8 24
648 9 = 9 23
648 10 = 10 22
648 11 = 11 21
648 12 = 12 20
648 12' = 649 1 19
661 6 = 661 7 2
692 11 = 12 13
698 10 = 11 8
743 10 = 10 23
757 1 = 1 25
762 1 = 1 29
762 2 = 2 28
762 12 = 12 20
762 12' = 763 1 19
763 1 = 2 17
765 2 = 2 24
765 12 = 766 1 15
768 5 = 5 21
768 6 = 6 19
768 6' = 7 19
770 1 = 2 1
790 3 = 3 21
791 2 = 3 9
791 5 = 6 7
807 10 = 11 4
810 11 = 12 1
818 5 = 6 8
820 2 = 3 19
820 3 = 4 17
820 7 = 8 13
823 10 = 11 7
828 9 = 10 13
861 6 = 861 7 12
889 5 = 6 2
1092 6 = 7 8
1314 1 = 1 17
1314 2 = 2 15
1314 3 = 3 17
1314 3' = 4 16
1314 4 = 5 15
1348 1 = 1 31
1348 2 = 3 1
1348 3 = 3 31
};

my $data2 = q{
1843 7 = 7 27
1843 8 = 8 25
1843 9 = 9 24
1843 9' = 10 23
1843 10 = 11 22
1846 5 = 5 25
1846 5' = 6 24
1846 6 = 7 23
1850 8 = 9 6
1850 9 = 10 6
1850 10 = 11 4
1850 11 = 12 4
1865 4 = 4 25
1865 5 = 5 25
1865 5' = 6 23
1865 6 = 7 23
1866 3 = 4 15
1866 4 = 5 15
1866 5 = 6 13
1866 6 = 7 12
};

use DateTime::Calendar::Julian;
use DateTime;
sub j2g ($$$) {
  my ($y, $m, $d) = @_;
  my $dt = DateTime::Calendar::Julian->new (year => $y, month => $m, day => $d);
  my $dt2 = DateTime->from_object (object => $dt);
  return ($dt2->year, $dt2->month, $dt2->day);
}

for (split /\x0D?\x0A/, $data1) {
  if (/^(\d+)\s+(\d+)('|)\s+=\s+(\d+)\s+(\d+)$/) {
    my $old = sprintf '%04d-%02d%s-01', $1, $2, $3;
    my ($y, $m, $d) = j2g $1, $4, $5;
    my $new = sprintf '%04d-%02d-%02d', $y, $m, $d;
    $Data->{mapping}->{$new} = $old;
  } elsif (/^(\d+)\s+(\d+)('|)\s+=\s+(\d+)\s+(\d+)\s+(\d+)$/) {
    my $old = sprintf '%04d-%02d%s-01', $1, $2, $3;
    my ($y, $m, $d) = j2g $4, $5, $6;
    my $new = sprintf '%04d-%02d-%02d', $y, $m, $d;
    $Data->{mapping}->{$new} = $old;
  } elsif (/\S/) {
    die "Broken line |$_|";
  }
}

for (split /\x0D?\x0A/, $data2) {
  if (/^(\d+)\s+(\d+)('|)\s+=\s+(\d+)\s+(\d+)$/) {
    my $old = sprintf '%04d-%02d%s-01', $1, $2, $3;
    my $new = sprintf '%04d-%02d-%02d', $1, $4, $5;
    $Data->{mapping}->{$new} = $old;
  } elsif (/^(\d+)\s+(\d+)('|)\s+=\s+(\d+)\s+(\d+)\s+(\d+)$/) {
    my $old = sprintf '%04d-%02d%s-01', $1, $2, $3;
    my $new = sprintf '%04d-%02d-%02d', $4, $5, $6;
    $Data->{mapping}->{$new} = $old;
  } elsif (/\S/) {
    die "Broken line |$_|";
  }
}

sub parse_list ($) {
  my @list;
  for (split /\x0D?\x0A/, $_[0]) {
    if (/^(\d+)\s+(\d+'?(?:,\d+'?)*)$/) {
      my $year = $1;
      for (split /,/, $2) {
        my $leap = s/'$//;
        push @list, sprintf '%04d-%02d%s-01', $year, $_, $leap ? "'" : '';
      }
    } elsif (/\S/) {
      die "Broken data |$_|";
    }
  }
  return @list;
}

## 日本暦日原典第4版より注釈

## 矛盾する史料等があるが計算値のまま修正せず
$Data->{notes}->{$_}->{use_computed_value} = 1 for parse_list q(
553 5
570 4'
575 2
628 4
628 9
649 5
649 5
770 1
821 8,9
);
$Data->{notes}->{$_}->{use_computed_value} = 1 for parse_list q(
734 10
734 11
736 12
737 1
742 12
743 1
743 10
744 11
744 12
748 1
748 2
748 3
748 4
748 5
748 6
748 7
748 8
748 9
748 10
748 11
748 12
);

## 記録に合わせて計算値を修正
$Data->{notes}->{$_}->{use_fixed_value} = 1 for parse_list q(
692 11
696 12
697 4
697 8
697 10
697 10'
697 11
697 12
697 12'
726 9
757 1
760 7
761 8
762 1
762 2
762 12'
763 1
763 1'
766 4
768 5
768 5'
768 6
768 6'
768 4
773 1,4,10
774 1,12
775 6,9
776 7',8,8'
777 3,6,8,12
778 4,5,6,7
779 5,12
780 1,3,12
781 1
783 8,10
785 5,11
786 6
787 4
790 3,8
791 5,7
792 3,19,11'
794 5
795 1,9
796 1
797 10
798 2
799 1,4
806 1,12
807 1,10
808 11
810 11
813 8
816 12
817 10
818 5
819 1,3
820 2,3,7
822 2
823 10
826 1
828 1,2,3,9
830 6,7
831 9
832 1,2
835 1
837 8,10
838 9
839 8,12
842 3,12
844 6,9
845 10,12
846 11
847 5,11
848 11
849 11
850 2
853 7
854 12
855 1,2,12
856 10
857 1,10
858 2
859 10
860 2,9,9',10,10',11
861 1,4,6
873 1
874 1,2
889 1
891 1,7
892 1
894 5
937 1,2,12
938 1,2
942 11
965 1
973 4
975 10
977 9
982 4
983 2
994 4,6
997 4,6
1014 3
1018 10
1026 9
1030 1
1034 8
1037 4
1050 10',11,12
1063 10
1069 10',11,11'
1082 5
1089 1
1095 1
1129 7',8,8'
1138 1
1156 11
1157 1
1164 10',11,11'
1183 10',11,11'
1187 8
1202 10',11,11'
1221 10',11,11',12
1228 1
1243 7',8,8'
1259 10',11,11'
1270 11'
1278 10',11,11'
1281 7',8,8'
1297 10',11,11'
1308 11,12
1316 10',11,11',12
1317 1,3
1335 10',11,11',12
1336 1,3
1338 7',8,8'
1344 1
1357 7',8,8'
1373 10',11,11'
1376 7',8,8'
1392 10',11,11'
1395 7',8,8',9,12
1396 5
1411 10',11,11'
1433 9
1434 1
1441 11,12
1449 10',11,11',12,12'
1450 1
1468 10',11,11',12
1473 7
1479 11
1555 11,12
);
$Data->{notes}->{$_}->{use_fixed_value} = 1 for parse_list q(
731 7
733 3
);
$Data->{notes}->{$_}->{use_fixed_value} = 1 for parse_list q(
1374 3
); ## 三島暦と異なる (京暦を採用)

## 推測される計算法によっては異なる値となり得る
$Data->{notes}->{$_}->{vary_by_algorithm} = 1 for parse_list q(
698 9
698 10
704 4
711 9
721 8
729 2
736 1
751 12
755 10
);

## 進朔の可能性が強い
$Data->{notes}->{$_}->{might_be_advanced} = 1 for parse_list q(
765 2,12
769 9
770 5
782 9
783 3,12
784 10
786 11
787 10
788 2
793 12
794 10
798 10
801 6
802 4
805 9
806 9
808 11
816 12
818 3,12
824 2
825 5
826 10
827 2,7
);

$Data->{notes}->{$_}->{misc_note} = 1 for parse_list q(
836 4
892 5
904 5
1773 3'
1775 12'
1786 10'
);

$data_path->child ('genten-data.json')->spew (perl2json_bytes_for_record $Data);
